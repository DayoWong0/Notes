# 第 2 章算法

## 2.4 算法定义

> 算法：
> 算法是解决特定问题求解步骤的描述，在计算机中表现为指令的有限序列，并且每条指令表示一个或多个操作。

## 2.5 算法的特征

> 算法具有五个基本特性：输入、输出、有穷性、确定性和可行性。

## 2.6 算法设计的要求

### 2.6.1 正确性

大体分为以下四个层次。

1. 算法程序没有语法错误。

2. 算法程序对于合法的输入数据能够产生满足要求的输出结果。
3. 算法程序对于非法的输入数据能够得出满足规格说明的结果。
4. 算法程序对于精心选择的，甚至刁难的测试数据都有满足要求的输出结果。

> 算法的正确性在大部分情况下都不可能用程序来证明，而是用数学方法证明的。证明一个复杂算法在所有层次上都是正确的，代价非常昂贵。所以一般情况下，我们把层次 3 作为一个算法是否正确的标准。

### 2.6.2 可读性

### 2.6.3 健壮性

> “健壮性：当输入数据不合法时，算法也能做出相关处理，而不是产生异常或莫名其妙的结果。”

### 2.6.4 时间效率高和存储量低

## 2.7 算法效率的度量方法

- 事后统计法
- 事前分析估算方法

一个用高级程序语言编写的程序在计算机上运行时所消耗的时间取决于下列因素：

1. 算法采用的策略、方法。
2. 编译产生的代码质量。
3. 问题的输入规模。
4. 机器执行指令的速度。

> 抛开这些与计算机硬件、软件有关的因素，一个程序的运行时间，依赖于算法的好坏和问题的输入规模。所谓问题输入规模是指输入量的多少

> 我们在分析一个算法的运行时间时，重要的是把基本操作的数量与输入规模关联起来，即基本操作的数量必须表示成输入规模的函数

## 2.8 　函数的渐近增长

> 我们给出这样的定义，输入规模 n 在没有限制的情况下，只要超过一个数值 N，这个函数就总是大于另一个函数，我们称函数是渐近增长的

> 函数的渐近增长：给定两个函数 f(n)和 g(n)，如果存在一个整数 N，使得对于所有的 n>N，f(n)总是比 g(n)大，那么，我们说 f(n)的增长渐近快于 g(n)

作者在书中列举了多个例子，得出了以下重要结论，这作为之后的算法效率判断依据

> 判断一个算法的效率时，函数中的常数和其他次要项常常可以忽略，而更应该关注主项（最高阶项）的阶数

> 判断一个算法好不好，我们只通过少量的数据是不能做出准确判断的。根据刚才的几个样例，我们发现，如果我们可以对比这几个算法的关键执行次数函数的渐近增长性，基本就可以分析出：某个算法，随着 n 的增大，它会越来越优于另一算法，或者越来越差于另一算法。这其实就是事前估算方法的理论依据，通过算法时间复杂度来估算算法时间效率。

## 2.9 算法时间复杂度

### 2.9.1 算法时间复杂度定义

> “在进行算法分析时，语句总的执行次数 T(n)是关于问题规模 n 的函数，进而分析 T(n)随 n 的变化情况并确定 T(n)的数量级。算法的时间复杂度，也就是算法的时间量度，记作：T(n)=O(f(n))。它表示随问题规模 n 的增大，算法执行时间的增长率和 f(n)的增长率相同，称作算法的渐近时间复杂度，简称为时间复杂度。其中 f(n)是问题规模 n 的某个函数。”

### 2.9.2 推导大 O 阶方法

> “推导大 O 阶：
>
> 1．用常数 1 取代运行时间中的所有加法常数。
>
> 2．在修改后的运行次数函数中，只保留最高阶项。
>
> 3．如果最高阶项存在且不是 1，则去除与这个项相乘的常数。
>
> 得到的结果就是大 O 阶”

### 2.9.3 常数阶

> 与问题的大小无关（n 的多少），执行时间恒定的算法，我们称之为具有 O(1)的时间复杂度，又叫常数阶。
>
> 注意：不管这个常数是多少，我们都记作 O(1)，而不能是 O(3)、O(12)等其他任何数字，这是初学者常常犯的错误。
>
> “对于分支结构而言，无论是真，还是假，执行的次数都是恒定的，不会随着 n 的变大而发生变化，所以单纯的分支结构（不包含在循环结构中），其时间复杂度也是 O(1)”

- 执行次数固定(不随输入 n 的大小改变)，单纯分支结构时间复杂度为 O（1）

### 2.9.4 线性阶

```c
int i;
for (i = 0; i < n; i++)
{
    /* 时间复杂度为O(1)的程序步骤序列 */
}
```

### 2.9.5 对数阶

```c
int count = 1;
while (count < n){
    count = count * 2;
    /* 时间复杂度为O(1)的程序步骤序列 */
}
```

### 2.9.6 　平方阶

```c
int i, j;
for (i = 0; i < n; i++)
{
    for (j = 0; j < n; j++)
    {
        /* 时间复杂度为O(1)的程序步骤序列 */
    }
}
```

for 循环嵌套

> 大 O 推导不算难，难的是对数列的一些相关运算，这更多的是考察你的数学知识和能力，所以想考研的朋友，要想在求算法时间复杂度这里不失分，可能需要强化你的数学，特别是数列方面的知识和解题能力

## 2.10 常见的时间复杂度

![image-20210201230513678](img/%E7%AC%AC2%E7%AB%A0%E7%AE%97%E6%B3%95/image-20210201230513678.png)

> 像O(n3)，过大的n都会使得结果变得不现实。
>
> 同样指数阶O(2n)和阶乘阶O(n!)等除非是很小的n值，
>
> 否则哪怕n只是100，都是噩梦般的运行时间。所以这种
>
> 不切实际的算法时间复杂度，一般我们都不去讨论它

## 2.11 最坏情况与平均情况

> 我们查找一个有n个随机数字数组中的某个数字，最好的情况是第一个数字就是，那么算法的时间复杂度为O(1)，但也有可能这个数字就在最后一个位置上待着，那么算法的时间复杂度就是O(n)，这是最坏的一种情况了
>

> 通常，除非特别指定，我们提到的运行时间都是最坏情况的运行时间
>

## 2.12 算法空间复杂度

> 算法的空间复杂度通过计算算法所需的存储空间实现，算法空间复杂度的计算公式记作：S(n)=O(f(n))，其中，n为问题的规模，f(n)为语句关于n所占存储空间的函数。
>

> “通常，我们都使用“时间复杂度”来指运行时间的需求，使用“空间复杂度”指空间需求。当不用限定词地使用“复杂度”时，通常都是指时间复杂度。显然我们这本书重点要讲的还是算法的时间复杂度的问题”
>

