# 第 3 章 线性表

> 线性表：
> 零个或多个数据元素的有限序列。

## 3.3 线性表的抽象数据类型

```c
ADT 线性表(List)
Data
    线性表的数据对象集合为{a1, a2, ......, an}，每个元素的类型均为DataType。
    其中，除第一个元素a1外，每一个元素有且只有一个直接前驱元素，
    除了最后一个元素an外，每一个元素有且只有一个直接后继元素。
    数据元素之间的关系是一对一的关系。
Operation
    InitList(*L):          初始化操作，建立一个空的线性表L。
    ListEmpty(L):          若线性表为空，返回true，否则返回false。
    ClearList(*L):         将线性表清空。
    GetElem(L, i, *e):     将线性表L中的第i个位置元素值返回给e。
    LocateElem(L, e):      在线性表L中查找与给定值e相等的元素，
                           如果查找成功，返回该元素在表中序号表示成功；
```

> “当你传递一个参数给函数的时候，这个参数会不会在函数内被改动决定了使用什么参数形式。如果需要被改动，则需要传递指向这个参数的指针，如果不用被改动，可以直接传递这个参数。”
>

## 3.4 线性表的顺序存储结构

### 3.4.1 顺序存储定义

![image-20210201234646494](img/%E7%AC%AC3%E7%AB%A0%E7%BA%BF%E6%80%A7%E8%A1%A8/image-20210201234646494.png)

### 3.4.2 顺序存储方式

一维数组实现顺序存储结构，需提前估计该线性表的最大存储容量

结构代码

```c
/* 存储空间初始分配量 */
#define MAXSIZE 20             
/* ElemType类型根据实际情况而定，这里假设为int */
typedef int ElemType;          
typedef struct
{
    /* 数组存储数据元素，最大值为MAXSIZE */
    ElemType data[MAXSIZE];    
    /* 线性表当前长度 */
    int length;              
} SqList;
```

### 3.4.3 数组长度与线性表长度区别

> 数组的长度是存放线性表的存储空间的长度，存储分配后这个量一般是不变的

> 线性表的长度是线性表中数据元素的个数，随着线性表插入和删除操作的进行，这个量是变化的。
>
> 在任意时刻，线性表的长度应该小于等于数组的长度。
>

### 3.4.4 地址计算方法

线性表从 1 开始计数，数组从 0 开始计数，所以有以下对应关系：线性表的第 i 个元素要存储在数组下标为 i - 1 的位置

![image-20210202102111809](img/%E7%AC%AC3%E7%AB%A0%E7%BA%BF%E6%80%A7%E8%A1%A8/image-20210202102111809.png)

对于第 i 个数据元素 ai 的存储位置可以由 a1 推算得出

![image-20210202102642097](img/%E7%AC%AC3%E7%AB%A0%E7%BA%BF%E6%80%A7%E8%A1%A8/image-20210202102642097.png)

> “通过这个公式，你可以随时算出线性表中任意位置的地址，不管它是第一个还是最后一个，都是相同的时间。那么`我们对每个线性表位置的存入或者取出数据，对于计算机来说都是相等的时间，也就是一个常数`，因此用我们算法中学到的时间复杂度的概念来说，它的存取时间性能为O(1)。我们通常把具有这一特点的存储结构称为`随机存取结构`”
>

## 3.5 顺序存储结构的插入与删除

### 3.5.1 获得元素操作

获取第 i 个元素，返回数组第 i - 1 个元素即可

```c
#define OK 1
#define ERROR 0
#define TRUE 1
#define FALSE 0
typedef int Status;
/* Status是函数的类型，其值是函数结果状态代
   码，如OK等 */
/* 初始条件：顺序线性表L已存在，1≤i≤
   ListLength(L) */
/* 操作结果：用e返回L中第i个数据元素的值 */
Status GetElem(SqList L, int i, ElemType *e)
{
    if (L.length == 0 || i < 1 || i > L.length){
        return ERROR;
    }
    *e = L.data[i - 1];
  return OK;
}
```

### 3.5.2 插入操作



![image-20210202103556346](img/%E7%AC%AC3%E7%AB%A0%E7%BA%BF%E6%80%A7%E8%A1%A8/image-20210202103556346.png)

插入算法的思路：

- 如果插入位置不合理，抛出异常；
- 如果线性表长度大于等于数组长度，则抛出异常或动态增加容量；
- 从最后一个元素开始向前遍历到第i个位置，分别将它们都向后移动一个位置；
- 将要插入元素填入位置 i 处； 表长加1

```c
/* 初始条件：顺序线性表L已存在，1≤i≤
   ListLength(L)， */
/* 操作结果：在L中第i个位置之前插入新的数据元素e，L的长度加1 */
Status ListInsert(SqList *L, int i, ElemType e)
{
    int k;
    /* 顺序线性表已经满 */
    if (L->length == MAXSIZE)                       
        return ERROR;
    /* 当i不在范围内时 */
    if (i < 1 || i >L->length + 1)                  
        return ERROR;
    /* 若插入数据位置不在表尾 */
    if (i <= L->length)                             
    {
        /*将要插入位置后数据元素向后移动一位 */
        for (k = L->length - 1; k >= i - 1; k--)    
            L->data[k + 1] = L->data[k];
    }
    /* 将新元素插入 */
    L->data[i - 1] = e;                             
    L->length++;
    return OK;
}
```

### 3.5.3 删除操作

![image-20210202104655286](img/%E7%AC%AC3%E7%AB%A0%E7%BA%BF%E6%80%A7%E8%A1%A8/image-20210202104655286.png)

删除算法的思路：

- 如果删除位置不合理抛出异常
- 取出删除元素
- 从删除元素位置开始遍历到最后一个元素位置，分别将它们向前移动一个位置
- 表长减一

```c
/* 初始条件：顺序线性表L已存在，1≤i≤
 ListLength(L) */
/* 操作结果：删除L的第i个数据元素，并用e返回
其值，L的长度减1 */
Status ListDelete(SqList *L, int i, ElemType *e)
{
 int k;
 /* 线性表为空 */
 if (L->length == 0) 
 return ERROR;
 /* 删除位置不正确 */
 if (i < 1 || i > L->length) 
 return ERROR;
 *e = L->data[i - 1];
 /* 如果删除不是最后位置 */
 if (i < L->length) 
 {
 /* 将删除位置后继元素前移 */
 for (k = i; k < L->length; k++) 
 L->data[k - 1] = L->data[k];
 }
 L->length--;
 return OK;
```

#### 插入和删除的时间复杂度

- 先来看最好的情况，如果元素要插入到最后一个位置，或者删除最后

  一个元素，此时时间复杂度为O(1)，因为不需要移动元素的

- 最坏的情况呢，如果元素要插入到第一个位置或者删除第一个元素，

  此时时间复杂度是多少呢？那就意味着要移动所有的元素向后或者向

  前，所以这个时间复杂度为O(n)

- 至于平均的情况，由于元素插入到第i个位置，或删除第i个元素，需

  要移动n-i个元素。根据概率原理，每个位置插入或删除元素的可能性

  是相同的，也就说位置靠前，移动元素多，位置靠后，移动元素少。

  最终平均移动次数和最中间的那个元素的移动次数相等，为(n-1)/2。

  我们前面讨论过时间复杂度的推导，可以得出，平均时间复杂度还是

  O(n)

> 线性表的顺序存储结构，在存、读数据时，不管是哪个
>
> 位置，时间复杂度都是O(1)；而插入或删除时，时间复杂度都是
>
> O(n)。这就说明，它比较适合元素个数不太变化，而更多是存取数据
>
> 的应用。

### 3.5.4 线性表顺序存储结构的优缺点

![image-20210202121207386](img/%E7%AC%AC3%E7%AB%A0%E7%BA%BF%E6%80%A7%E8%A1%A8/image-20210202121207386.png)

## 3.6 线性表的链式存储结构

### **3.6.2** 线性表链式存储结构定义

![image-20210202121806412](img/%E7%AC%AC3%E7%AB%A0%E7%BA%BF%E6%80%A7%E8%A1%A8/image-20210202121806412.png)

> 线性表的链式存储结构的特点是用一组任意的存储单元存储线性表的数据元素，这组存储单元可以是连续的，也可以是不连续的。这就意味着，这些数据元素可以存在内存未被占用的任意位置（如图所示）

> 除了存储其本身的信息之外，还需存储一个指示其直接后继的
> 信息（即直接后继的存储位置）。
>
> 我们把存储数据元素信息的域称为数据域，
>
> 把存储直接后继位置的域称为指针域。
>
> 指针域中存储的信息称做指针或链。
>
> 这两部分信息组成数据元素ai的存储映像，称为结点（Node）。

> n个结点（ai的存储映像）链结成一个链表，即为线性表（a1 ,a2 ,...,an）的链式存储结构，因为此链表的`每个结点中只包含一个指针域`，所以叫做单链表。单链表正是通过每个结点的指针域将线性表的数据元素按其逻辑次序链接在一起
>
> ![image-20210202122250741](img/%E7%AC%AC3%E7%AB%A0%E7%BA%BF%E6%80%A7%E8%A1%A8/image-20210202122250741.png)

#### 头指针

> 我们把链表中
>
> 第一个结点的存储位置叫做头指针，那么整个链表的存取就必须是从头指针开始进行了。之后的每一个结点，其实就是上一个的后继指针
>
> 指向的位置。想象一下，最后一个结点，它的指针指向哪里？
>
> 最后一个，当然就意味着直接后继不存在了，所以我们规定，线性链
>
> 表的最后一个结点指针为“空”（通常用NULL或“^”符号表示)
>
> ![image-20210202122556705](img/%E7%AC%AC3%E7%AB%A0%E7%BA%BF%E6%80%A7%E8%A1%A8/image-20210202122556705.png)

> 有时，我们为了更加方便地对链表进行操作，会在单链表的第一个结
>
> 点前附设一个结点，称为头结点。头结点的数据域可以不存储任何信
>
> 息，谁叫它是第一个呢，有这个特权。也可以存储如线性表的长度等
>
> 附加信息，头结点的指针域存储指向第一个结点的指针
>
> ![image-20210202122939503](img/%E7%AC%AC3%E7%AB%A0%E7%BA%BF%E6%80%A7%E8%A1%A8/image-20210202122939503.png)

### **3.6.3** 头指针与头结点的异同

![image-20210202123549952](img/%E7%AC%AC3%E7%AB%A0%E7%BA%BF%E6%80%A7%E8%A1%A8/image-20210202123549952.png)

### 3.6.4 线性表链式存储结构代码描述

![image-20210202123850848](img/%E7%AC%AC3%E7%AB%A0%E7%BA%BF%E6%80%A7%E8%A1%A8/image-20210202123850848.png)

若带有头结点的单链表

![image-20210202123906043](img/%E7%AC%AC3%E7%AB%A0%E7%BA%BF%E6%80%A7%E8%A1%A8/image-20210202123906043.png)

单链表定义

```c
/* 线性表的单链表存储结构 */
typedef struct Node
{
 ElemType data;
 struct Node *next;
} Node;
/* 定义LinkList */
typedef struct Node *LinkList;
```

![image-20210202124201114](img/%E7%AC%AC3%E7%AB%A0%E7%BA%BF%E6%80%A7%E8%A1%A8/image-20210202124201114.png)

## **3.7** 单链表的读取

> 获得链表第i个数据的算法思路：
>
> 1.声明一个指针p指向链表第一个结点，初始化j从1开始；
>
> 2.当j<i时，就遍历链表，让p的指针向后移动，不断指向下一结点，j
>
> 累加1；
>
> 3.若到链表末尾p为空，则说明第i个结点不存在；
>
> 4.否则查找成功，返回结点p的数据。

```c
/* 初始条件：顺序线性表L已存在，1≤i≤
 ListLength(L) */
/* 操作结果：用e返回L中第i个数据元素的值 */
Status GetElem(LinkList L, int i, ElemType *e)
{
 int j;
 LinkList p; /* 声明一指针p */
 p = L->next; /* 让p指向链表L的第个结点 */
 j = 1; /* j为计数器 */
 /* p不为空且计数器j还没有等于i时，循环继续 */
 while (p && j < i) 
 {
 p = p->next; /* 让p指向下一个结点 */
 ++j;
 }
 if (!p || j > i)
第i个结点不存在
 return ERROR; /* 第i个结点不存在 */
 *e = p->data; /* 取第i个结点的数据 */
 return OK;
}
```

> 说白了，就是从头开始找，直到第i个结点为止。由于这个算法的时间
>
> 复杂度取决于i的位置，当i=1时，则不需遍历，第一个就取出数据
>
> 了，而当i=n时则遍历n-1次才可以。因此最坏情况的时间复杂度是
>
> O(n)

## 3.8 单链表的插入与删除

### 3.8.1 单链表的插入

只需将结点 s 插入到结点 p 和 p-> next之间即可

![image-20210202124919540](img/%E7%AC%AC3%E7%AB%A0%E7%BA%BF%E6%80%A7%E8%A1%A8/image-20210202124919540.png)

只需要让s->next和p->next的指针做一点改变即可（赋值顺序不可变）

```c
s->next = p->next; p->next = s;
```

![image-20210202125245520](img/%E7%AC%AC3%E7%AB%A0%E7%BA%BF%E6%80%A7%E8%A1%A8/image-20210202125245520.png)

> 考虑一下，这两句的顺序可不可以交换？
>
> 如果先p->next=s;再s->next=p->next;会怎么样？哈哈，因为此
>
> 时第一句会使得将p->next给覆盖成s的地址了。那么s->next=p-\>next，其实就等于s->next=s，这样真正的拥有a
>
> i+1数据元素的结点就没了上级。这样的插入操作就是失败的，造成
>
> 了临场掉链子的尴尬局面。所以这两句是无论如何不能反的，这点初
>
> 学者一定要注意

插入后

![image-20210202125428338](img/%E7%AC%AC3%E7%AB%A0%E7%BA%BF%E6%80%A7%E8%A1%A8/image-20210202125428338.png)

对于单链表的表头和表尾的特殊情况，操作是相同的（由一般到特殊）

![image-20210202125739086](img/%E7%AC%AC3%E7%AB%A0%E7%BA%BF%E6%80%A7%E8%A1%A8/image-20210202125739086.png)

单链表第i个数据插入结点的算法思路： 

1. 声明一指针p指向链表头结点，初始化j从1开始； 

2. 当j<i时，就遍历链表，让p的指针向后移动，不断指向下一结点，j累加1； 

3. 若到链表末尾p为空，则说明第i个结点不存在； 

4. 否则查找成功，在系统中生成一个空结点s； 

5. 将数据元素e赋值给s->data； 

6. 单链表的插入标准语句s->next=p-\>next;p->next=s； 
7. 返回成功。

```c
/* 初始条件：顺序线性表L已存在，1≤i≤
 ListLength(L)， */
/* 操作结果：在L中第i个结点位置之前插入新的数
据元素e，L的长度加1 */
Status ListInsert(LinkList *L, int i, ElemType e)
{
 int j;
 LinkList p, s;
 p = *L;
 j = 1;
 /* 寻找第i-1个结点 */
 while (p && j < i) 
 {
 p = p->next;
 ++j;
 }
 /* 第i个结点不存在 */
 if (!p || j > i)
 return ERROR; 
 /* 生成新结点（C标准函数） */
 s = (LinkList)malloc(sizeof(Node)); 
 s->data = e;
 /* 将p的后继结点赋值给s的后继 */
 s->next = p->next; 
 /* 将s赋值给p的后继 */
 p->next = s; 
 return OK;
}
```

### 3.8.2 单链表的删除

要实现将结点q删除单链表的操作，其实就是将它的前继结点的指针绕过，指向它的后继结点即可

![image-20210202130758596](img/%E7%AC%AC3%E7%AB%A0%E7%BA%BF%E6%80%A7%E8%A1%A8/image-20210202130758596.png)

我们所要做的，实际上就是一步，p->next=p->next->next，用q

来取代p->next（q 是个临时变量，查找到欲删除节点 ）即是：

```c
q=p->next; /* 获取到要被删除的节点赋值给 q* /
p->next=q->next; /* 将要删除的节点的前一个节点指针指向要删除的节点的后继节点*/
```

单链表第i个数据删除结点的算法思路：

1. 声明一指针p指向链表头结点，初始化j从1开始；

2. 当j<i时，就遍历链表，让p的指针向后移动，不断指向下一个结点，j累加1；

3. 若到链表末尾p为空，则说明第i个结点不存在；

4. 否则查找成功，将欲删除的结点p->next赋值给q（定位到欲删除节点的前一个节点）；

5. 单链表的删除标准语句p->next=q->next；

6. 将q结点中的数据赋值给e，作为返回；
7. 释放q结点；

8. 返回成功

```c
/* 初始条件：顺序线性表L已存在，1≤i≤
 ListLength(L) */
/* 操作结果：删除L的第i个结点，并用e返回其
值，L的长度减1 */
Status ListDelete(LinkList *L, int i, ElemType *e)
{
 int j;
 LinkList p, q;
 p = *L;
 j = 1;
 /* 遍历寻找第i-1个结点 */
 while (p->next && j < i) 
 {
 p = p->next;
 ++j;
 }
 /* 第i个结点不存在 */
 if (!(p->next) || j > i)
 return ERROR; 
 q = p->next;
 /* 将q的后继赋值给p的后继 */
 p->next = q->next; 
 /* 将q结点中的数据给e */
 *e = q->data; 
 /* 让系统回收此结点，释放内存 */
 free(q); 
 return OK;
}
```

> 分析一下刚才我们讲解的单链表插入和删除算法，我们发现，它们其
>
> 实都是由两部分组成：第一部分就是遍历查找第i个结点；第二部分就
>
> 是插入和删除结点。
>
> 从整个算法来说，我们很容易推导出：它们的时间复杂度都是O(n)。
>
> 如果在我们不知道第i个结点的指针位置，单链表数据结构在插入和删
>
> 除操作上，与线性表的顺序存储结构是没有太大优势的。但如果，我
>
> 们希望从第i个位置，插入10个结点，对于顺序存储结构意味着，每
>
> 一次插入都需要移动n-i个结点，每次都是O(n)。而单链表，我们只需
>
> 要在第一次时，找到第i个位置的指针，此时为O(n)，接下来只是简单
>
> 地通过赋值移动指针而已，时间复杂度都是O(1)。显然，对于插入或
>
> 删除数据越频繁的操作，单链表的效率优势就越是明显

`对于插入或删除数据越频繁的操作，单链表的效率优势就越是明显`

## 3.9 单链表的整表创建

单链表整表创建的算法思路：

1. 声明一指针p和计数器变量i；

2. 初始化一空链表L；

3. 让L的头结点的指针指向NULL，即建立一个带头结点的单链表；

4. 循环：
   1. 生成一新结点赋值给p；
   2. 随机生成一数字赋值给p的数据域p->data； 
   3. 将p插入到头结点与前一新结点之间。

```c
/* 随机产生n个元素的值，建立带表头结点的单链
线性表L（头插法） */
void CreateListHead(LinkList *L, int n)
{
 LinkList p;
 int i;
 /* 初始化随机数种子 */
 srand(time(0)); 
 *L = (LinkList)malloc(sizeof(Node));
 /* 先建立一个带头结点的单链表 */
 (*L)->next = NULL; 
 for (i = 0; i < n; i++)
 {
 /* 生成新结点 */
 p = (LinkList)malloc(sizeof(Node)); 
 /* 随机生成100以内的数字 */
 p->data = rand() % 100 + 1; 
 p->next = (*L)->next;
 /* 插入到表头 */
 (*L)->next = p; 
 }
}
```

这段算法代码里，我们其实用的是插队的办法，就是始终让新结点在

第一的位置。我也可以把这种算法简称为头插法

![image-20210202132811665](img/%E7%AC%AC3%E7%AB%A0%E7%BA%BF%E6%80%A7%E8%A1%A8/image-20210202132811665.png)

我们把每次新结点都插在终端结点的后面，这种算法称之为尾插法。

```c
/* 随机产生n个元素的值，建立带表头结点的单链
线性表L（尾插法） */
void CreateListTail(LinkList *L, int n)
{
 LinkList p,r;
 int i;
 /* 初始化随机数种子 */
 srand(time(0)); 
 /* 为整个线性表 */
 *L = (LinkList)malloc(sizeof(Node)); 
 /* r为指向尾部的结点 */
 r = *L; 
 for (i = 0; i < n; i++)
 {
 /* 生成新结点 */
 p = (Node *)malloc(sizeof(Node)); 
 /* 随机生成100以内的数字 */
 p->data = rand() % 100 + 1; 
 /* 将表尾终端结点的指针指向新结点 */
 r->next = p; 
 /* 将当前的新结点定义为表尾终端结点 */
 r = p; 
 }
 /* 表示当前链表结束 */
 r->next = NULL; 
}
```

## 3.10 单链表的整表删除

单链表整表删除的算法思路如下：

1. 声明一指针p和q；

2. 将第一个结点赋值给p；

3. 循环：
   1. 将下一结点赋值给q；
   2. 释放p； 
   3. 将q赋值给p。

```c
/* 初始条件：顺序线性表L已存在，操作结果：将L
重置为空表 */
Status ClearList(LinkList *L)
{
 LinkList p, q;
 /* p指向第一个结点 */
 p = (*L)->next; 
 /* 没到表尾 */
 while (p) 
 {
 q = p->next;
 free(p);
 p=q;
 }
 /* 头结点指针域为空 */
 (*L)->next = NULL; 
 return OK;
; }
```

## 3.11 单链表结构与顺序存储结构优缺点

