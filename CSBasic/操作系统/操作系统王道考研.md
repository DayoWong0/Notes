# [操作系统王道考研](https://www.bilibili.com/video/BV1YE411D7nH?p=2)

参考资料:

[课程 PPT](https://github.com/chengziqaq/Note/tree/master/cs/csBasic/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/20%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%AF%BE%E4%BB%B6-%E7%8E%8B%E9%81%93%E8%80%83%E7%A0%94)

# 操作系统概述

## 操作系统的特征

### 并发和并行区别

- 并发：宏观同时发生，微观交替发生。CPU 切换时间纳秒级别
- 并行：真正的同时发生

### 共享

- 互斥共享：同一时间仅一个进程访问该资源
- 同时共享：允许“同时”多个进程访问同一资源（宏观上同时 微观上交替）

### 虚拟

- 时分复用技术
- 空分复用技术

### 异步

定义：多个程序并发执行，由于资源有限，进程走走停停执行到底，以不可预知的速度向前推进。

## 操作系统的发展与分类

- 手工操作阶段
- 单道批处理系统
- 多道批处理系统：操作系统正式诞生,资源利用率大幅提升，但是没有人机交互
- 分时操作系统：以时间片为单位轮流为各个用户/作业 服务。不能优先处理紧急任务。
- 实时操作系统：能优先相应紧急任务。及时性和可靠性。

  - 硬实时操作系统：在绝对严格的规定时间内完成处理
  - 软实时操作系统：能偶尔违反时间规定

- 网络操作系统 分布式操作系统 个人计算机操作系统 仅了解

## 操作系统的运行机制与体系结构

![](pic/image-20200630104005256.png)

### 两种指令

- 特权指令：不允许用户程序使用
- 非特权指令

### 两种 CPU 状态

用 程序状态字寄存器（PSW）中的某标志位来标识当前处理器处于什么状态。0 用户态 1 核心态（计算机组成原理内容）

- 用户态（目态）：只能执行非特权指令
- 核心态（管态）：特权和非特权指令都能执行

### 两种程序

- 内核程序：两种指令都可执行，运行在核心态
- 应用程序：非特权指令。

### 操作系统内核

![image-20200630105302226](pic/image-20200630105302226.png)

![image-20200630105412139](pic/image-20200630105412139.png)

- 大内核、微内核

  ![image-20200630105640600](pic/image-20200630105640600.png)

![image-20200630105858357](pic/image-20200630105858357.png)

以管理公司为例子容易理解

### 知识回顾

![image-20200630110020646](pic/image-20200630110020646.png)

## 中断和异常

![image-20200630110216169](pic/image-20200630110216169.png)

### 中断机制的诞生

发生中断需要操作系统介入，开展管理工作

![image-20200630111642805](pic/image-20200630111642805.png)

### 中断分类

- 内中断（异常、例外、陷入）：信号来源于 CPU 内部
- 外中断

![image-20200630111918678](pic/image-20200630111918678.png)

![image-20200630111951274](pic/image-20200630111951274.png)

### 外中断的处理过程

![image-20200630112147938](pic/image-20200630112147938.png)

### 知识回顾

![image-20200630112310710](pic/image-20200630112310710.png)

## 系统调用

### 知识总览

![image-20200630112344031](pic/image-20200630112344031.png)

### 什么是系统调用以及作用

操作系统掌管硬件，用户程序只能通过系统调用申请使用硬件。

![image-20200630112738826](pic/image-20200630112738826.png)

### 系统调用与库函数的区别

![image-20200630113014731](pic/image-20200630113014731.png)

自己的理解：部分库函数（如文件操作）封装了需要的系统调用，库函数屏蔽了系统调用细节，使得我们写的代码更具有通用性（可能是高级语言封装了多个操作系统的系统调用）

### 系统调用背后的过程

![image-20200630113403677](pic/image-20200630113403677.png)

![image-20200630113716393](pic/image-20200630113716393.png)

![image-20200630113855710](pic/image-20200630113855710.png)

# 进程

## 进程的定义、组成、组织方式、特征

![image-20200630114115988](pic/image-20200630114115988.png)

### 进程定义

- 程序：就是一个指令序列

![image-20200630120423955](pic/image-20200630120423955.png)

![image-20200630120715322](pic/image-20200630120715322.png)

![image-20200630120836567](pic/image-20200630120836567.png)

### 进程的组成

![image-20200630121026580](pic/image-20200630121026580.png)

![image-20200630121110388](pic/image-20200630121110388.png)

### 进程的组织

![image-20200630121231915](pic/image-20200630121231915.png)

#### 链接方式

![image-20200630121446436](pic/image-20200630121446436.png)

#### 索引方式

![image-20200630121604352](pic/image-20200630121604352.png)

### 进程的特征

![image-20200630121846271](pic/image-20200630121846271.png)

### 回顾

![image-20200630122204899](pic/image-20200630122204899.png)

## 进程的状态与转换

![image-20200630122303319](pic/image-20200630122303319.png)

### 进程的状态

- 三种基本状态

![image-20200630123839128](pic/image-20200630123839128.png)

- 另外两种状态--创建、终止态

![image-20200630124718092](pic/image-20200630124718092.png)

### 进程状态的转化

![image-20200630125651028](pic/image-20200630125651028.png)

注意：

- 运行态--->阻塞态：应用程序申请硬件资源（系统调用）或者等待某个事件发生，做出的主动行为
- 不能由阻塞态直接转为运行态，应该：阻塞态--->就绪态-->运行态
- 也不能从就绪态直接转阻塞态

### 知识回顾

![image-20200630125930359](pic/image-20200630125930359.png)

## 进程控制

![image-20200630130209787](pic/image-20200630130209787.png)

### 定义

![image-20200630130412020](pic/image-20200630130412020.png)

### 如何实现进程控制

![image-20200630130457439](pic/image-20200630130457439.png)

![image-20200630130727399](pic/image-20200630130727399.png)

![image-20200630130918705](pic/image-20200630130918705.png)

名词：原语

### 进程控制相关的原语

![image-20200630131222138](pic/image-20200630131222138.png)

#### 进程的创建原语

![image-20200630131241579](pic/image-20200630131241579.png)

#### 进程的终止原语

![image-20200630131402945](pic/image-20200630131402945.png)

#### 进程的阻塞和唤醒原语

![image-20200630131418109](pic/image-20200630131418109.png)

#### 进程的切换

![image-20200630131811032](pic/image-20200630131811032.png)

### 知识回顾

![image-20200630131902934](pic/image-20200630131902934.png)

## 进程通信

![image-20200630132447240](pic/image-20200630132447240.png)

#### 共享存储

![image-20200630142400141](pic/image-20200630142400141.png)

#### 消息传递

![image-20200630142901121](pic/image-20200630142901121.png)

#### 管道通信

![image-20200630142705516](pic/image-20200630142705516.png)

#### 知识回顾

![image-20200630143023791](pic/image-20200630143023791.png)

# 线程

![image-20200630143511812](pic/image-20200630143511812.png)

## 线程概念

![image-20200630143820952](pic/image-20200630143820952.png)

![image-20200630144857969](pic/image-20200630144857969.png)

![image-20200630145045560](pic/image-20200630145045560.png)

![image-20200630145422483](pic/image-20200630145422483.png)

## 线程的实现方式

### 用户级线程 ULT（User-Level Thread）

![image-20200630145756751](pic/image-20200630145756751.png)

### 内核级线程（KLT，Kernel-Level Thread）

![image-20200630150001007](pic/image-20200630150001007.png)

### 两者结合

![image-20200630150208823](pic/image-20200630150208823.png)

### 多线程模型

#### 多对一模型（未懂）

![image-20200630170914563](pic/image-20200630170914563.png)

#### 一对一模型

![image-20200630171036424](pic/image-20200630171036424.png)

#### 多对多模型

![image-20200630171222673](pic/image-20200630171222673.png)

### 知识回顾

![image-20200630171338786](pic/image-20200630171338786.png)

# 处理机调度

![image-20200630171521333](pic/image-20200630171521333.png)

## 调度的基本概念

![image-20200630171727242](pic/image-20200630171727242.png)

## 高级调度（作业调度）

![image-20200630172105825](pic/image-20200630172105825.png)

## 中级调度（内存调度）

![image-20200630172346795](pic/image-20200630172346795.png)

## 补充：进程的挂起态与七状态模型

![image-20200630172610492](pic/image-20200630172610492.png)

## 低级调度（进程调度）

![image-20200630172735393](pic/image-20200630172735393.png)

## 三种调度比较

![image-20200630173020835](pic/image-20200630173020835.png)

作业调度：进程创建

内存调度：挂起的程序调回内存

进程调度：内存的进程获得 CPU 资源。

## 知识回顾

![image-20200630173119804](pic/image-20200630173119804.png)

# 进程调度的时机切换与过程调度方式

![image-20200630173841576](pic/image-20200630173841576.png)

## 进程调度的时机

![image-20200630174320419](pic/image-20200630174320419.png)

![image-20200630174709246](pic/image-20200630174709246.png)

![image-20200630174836358](pic/image-20200630174836358.png)

## 进程调度的方式

### 非剥夺调度方式

### 剥夺调度方式

![image-20200630175141160](pic/image-20200630175141160.png)

## 进程的切换与过程

![image-20200630175629579](pic/image-20200630175629579.png)

### 狭义的进程调度与进程切换的区别

![image-20200630175444892](pic/image-20200630175444892.png)

## 知识回顾

![image-20200630175920217](pic/image-20200630175920217.png)

# Markdown 转 Xmind 分界线（以下内容不用修改，即可转 Xmind）

### 调度算法的评价指标（父节点：进程调度的时机切换与过程调度方式）

![image-20200630180315262](pic/image-20200630180315262.png)

#### CPU 利用率

![image-20200630180502905](pic/image-20200630180502905.png)

#### 系统吞吐量

![image-20200630180608409](pic/image-20200630180608409.png)

#### 周转时间

![image-20200630180758296](pic/image-20200630180758296.png)

![image-20200630180906301](pic/image-20200630180906301.png)

#### 等待时间

![image-20200630210144380](pic/image-20200630210144380.png)

#### 响应时间

![image-20200630210306959](pic/image-20200630210306959.png)

#### 知识回顾

![image-20200630210347548](pic/image-20200630210347548.png)

## 调度算法

![image-20200630210603625](pic/image-20200630210603625.png)

### 先来先服务（FCFS）

![image-20200630212740824](pic/image-20200630212740824.png)

![image-20200630213014042](pic/image-20200630213014042.png)

### 短作业优先（SJF）

![image-20200630213406784](pic/image-20200630213406784.png)

![image-20200630213617708](pic/image-20200630213617708.png)

![image-20200630213655932](pic/image-20200630213655932.png)

![image-20200630213836740](pic/image-20200630213836740.png)

![image-20200630213938600](pic/image-20200630213938600.png)

### 两种算法比较

![image-20200630214052799](pic/image-20200630214052799.png)

### 高响应比优先

![image-20200630214607037](pic/image-20200630214607037.png)

### 知识回顾

![image-20200630214716400](pic/image-20200630214716400.png)

### 其他算法

![image-20200630215031507](pic/image-20200630215031507.png)

### 时间片轮转

- [此节跳过没看](https://www.bilibili.com/video/BV1YE411D7nH?p=16)

## 进程同步与互斥

### 进程同步定义

由于进程具有异步性：各并发执行的进程以各自独立的、不可预测的速度向前推进。进程同步使得程序运行顺序由我们控制。

![image-20200630215342734](pic/image-20200630215342734.png)

![image-20200630221407939](pic/image-20200630221407939.png)

### 进程互斥定义

![image-20200630221844442](pic/image-20200630221844442.png)

![image-20200630222119979](pic/image-20200630222119979.png)

![image-20200630222316035](pic/image-20200630222316035.png)

### 知识回顾

![image-20200630222423377](pic/image-20200630222423377.png)

### 进程互斥的软件实现方法

![image-20200701144739412](pic/image-20200701144739412.png)

#### 单标志法

![image-20200701145058260](pic/image-20200701145058260.png)

#### 双标志先检查法

![image-20200701145500166](pic/image-20200701145500166.png)

#### 双标志后检查法

![image-20200701145641280](pic/image-20200701145641280.png)

#### Peterson 算法

![image-20200701150046762](pic/image-20200701150046762.png)

![image-20200701150158167](pic/image-20200701150158167.png)

#### 知识回顾

![image-20200701150257253](pic/image-20200701150257253.png)

### 进程互斥的硬件实现方法

![image-20200701150343274](pic/image-20200701150343274.png)

要求：了解方法的原理和优缺点

#### 中断屏蔽方法

![image-20200701150559793](pic/image-20200701150559793.png)

#### TestAndSet 指令

![image-20200701151120042](pic/image-20200701151120042.png)

#### Swap 指令

![image-20200701151300864](pic/image-20200701151300864.png)

#### 知识回顾

![image-20200701151319916](pic/image-20200701151319916.png)

## 信号量机制（P V 操作）

![image-20200701151544910](pic/image-20200701151544910.png)

![image-20200701151800674](pic/image-20200701151800674.png)

### 整形信号量

![image-20200701152130673](pic/image-20200701152130673.png)

### 记录型信号量

![image-20200701152319390](pic/image-20200701152319390.png)

![image-20200701152720605](pic/image-20200701152720605.png)

![image-20200701152845035](pic/image-20200701152845035.png)

#### 知识回顾

![image-20200701152953282](pic/image-20200701152953282.png)

### 实现进程互斥（前 P 后 V）

![image-20200701155450510](pic/image-20200701155450510.png)

### [实现进程同步（前 V 后 P）](https://www.bilibili.com/video/BV1YE411D7nH?p=21)

#### 进程同步定义

让并发进程按我们想要的顺序执行（并发进程有异步性（代码执行顺序不可预知））。如代码 3 需要在代码 1、2 后执行，而且代码 1，2 是同一个进程，3 为另一个进程。

![image-20200701155807260](pic/image-20200701155807260.png)

#### 实现进程同步（前 V 后 P）

![image-20200701160204627](pic/image-20200701160204627.png)

### 实现进程的前驱关系

![image-20200701160454985](pic/image-20200701160454985.png)

### 知识回顾

![image-20200701160848327](pic/image-20200701160848327.png)

## 经典进程同步互斥问题

### [生产者消费者问题](https://www.bilibili.com/video/BV1YE411D7nH?p=22)

![image-20200701161326818](pic/image-20200701161326818.png)

![image-20200701161637940](pic/image-20200701161637940.png)

![image-20200701161735463](pic/image-20200701161735463.png)

![image-20200701162317673](pic/image-20200701162317673.png)

P 减 V 加

#### 知识回顾

![image-20200701162455056](pic/image-20200701162455056.png)

### [多生产者-多消费者](https://www.bilibili.com/video/BV1YE411D7nH?p=23)

暂时跳过

### [吸烟者问题](https://www.bilibili.com/video/BV1YE411D7nH?p=24)

跳过

### [读者-写者问题](https://www.bilibili.com/video/BV1YE411D7nH?p=25)

跳过

### [哲学家就餐问题](https://www.bilibili.com/video/BV1YE411D7nH?p=26)

跳过

## [管程](https://www.bilibili.com/video/BV1YE411D7nH?p=27)

![image-20200701163233424](pic/image-20200701163233424.png)

### 为什么引入管程

![image-20200701163431766](pic/image-20200701163431766.png)

### 管程定义

一种高级同步机制，同信号量用于进程同步和互斥

![image-20200701163923247](pic/image-20200701163923247.png)

- 管程的组成：类似于 java 的 class

- 管程的基本特征

1、2：类似于 java 的 private 变量只能由类里的 getter 函数访问

3：一次只能有一个执行，访问缓冲区互斥

### 用管程解决生产中消费者问题

![image-20200702081308889](pic/image-20200702081308889.png)

左边伪码是管程原理，右边伪码是我们写代码时用的，这样与用信号量来控制同步与互斥比较很方便。简单说就是管程封装了方法，写代码直接调用。互斥特征由编译器实现。

![image-20200702081732815](pic/image-20200702081732815.png)

![image-20200702081850663](pic/image-20200702081850663.png)

![image-20200702081949995](pic/image-20200702081949995.png)

## 死锁

![image-20200702082000759](pic/image-20200702082000759.png)

### 死锁的概念

![image-20200702082050546](pic/image-20200702082050546.png)

![image-20200702082219200](pic/image-20200702082219200.png)

### 死锁、饥饿、死循环的区别

![image-20200702082547076](pic/image-20200702082547076.png)

死锁 饥饿 由操作系统管理

### 死锁产生的四个必要条件

![image-20200702082854042](pic/image-20200702082854042.png)

#### 互斥条件

#### 请求与保持条件

#### 不可剥夺条件

#### 循环等待条件

### 什么时候发生死锁

![image-20200702083309530](pic/image-20200702083309530.png)

### 死锁的处理策略

![image-20200702083354650](pic/image-20200702083354650.png)

![image-20200702083626885](pic/image-20200702083626885.png)

![image-20200702083657228](pic/image-20200702083657228.png)

#### 预防死锁

##### 破坏互斥条件

![image-20200702083949862](pic/image-20200702083949862.png)

##### 破坏不可剥夺条件

![image-20200702084139230](pic/image-20200702084139230.png)

##### 破坏请求和保持条件

![image-20200702084403908](pic/image-20200702084403908.png)

##### 破坏循环等待条件

![image-20200702084729902](pic/image-20200702084729902.png)

##### 知识回顾

![image-20200702084918842](pic/image-20200702084918842.png)

#### [避免死锁](https://www.bilibili.com/video/BV1YE411D7nH?p=30)

![image-20200702085000205](pic/image-20200702085000205.png)

##### 什么是安全序列

##### 安全序列、不安全状态、死锁的联系

![image-20200702085513940](pic/image-20200702085513940.png)

##### 银行家算法

![image-20200702085939710](pic/image-20200702085939710.png)

![image-20200702090049751](pic/image-20200702090049751.png)

![image-20200702090158860](pic/image-20200702090158860.png)

![image-20200702090234281](pic/image-20200702090234281.png)

不安全序列：可能发生死锁

![image-20200702090308173](pic/image-20200702090308173.png)

- 算法举例

  ![image-20200702090622675](pic/image-20200702090622675.png)

##### 知识回顾

![image-20200702090812961](pic/image-20200702090812961.png)

#### [检测和解除](https://www.bilibili.com/video/BV1YE411D7nH?p=31)

##### 死锁的检测

看视频更容易理解，截图不完整。

![image-20200702091156583](pic/image-20200702091156583.png)

![image-20200702091737922](pic/image-20200702091737922.png)

##### 死锁的解除

![image-20200702092049852](pic/image-20200702092049852.png)

##### 知识回顾

![image-20200702092142447](pic/image-20200702092142447.png)

## 内存

### [内存定义以及作用](https://www.bilibili.com/video/BV1YE411D7nH?p=32&t=29)

![image-20200702153412939](pic/image-20200702153412939.png)

### 内存大小

![image-20200702153816211](pic/image-20200702153816211.png)

### 指令

![image-20200702154119105](pic/image-20200702154119105.png)

#### 逻辑地址 vs 物理地址

![image-20200702154326499](pic/image-20200702154326499.png)

### 从写程序到程序运行

![image-20200702154550460](pic/image-20200702154550460.png)

#### 装入模块装入内存

![image-20200702154919709](pic/image-20200702154919709.png)

##### 装入的三种方式

##### 绝对装入

![image-20200702155125252](pic/image-20200702155125252.png)

##### 静态重定位

![image-20200702155442559](pic/image-20200702155442559.png)

##### 动态重定位

![image-20200702155713593](pic/image-20200702155713593.png)

#### 链接的三种方式

![image-20200702155844150](pic/image-20200702155844150.png)

### 内存基础知识回顾

![image-20200702160127410](pic/image-20200702160127410.png)

### 内存管理的概念

![image-20200702160216321](pic/image-20200702160216321.png)

#### 内存空间的分配与回收

![image-20200702160331964](pic/image-20200702160331964.png)

#### 内存空间的扩展

![image-20200702160849417](pic/image-20200702160849417.png)

#### 地址转换

![image-20200702160954947](pic/image-20200702160954947.png)

#### 内存保护

##### 设置一对上、下限寄存器

![image-20200702161127171](pic/image-20200702161127171.png)

##### 采用重定位寄存器（基址寄存器）和界地址寄存器（限长寄存器）

![image-20200702162416522](pic/image-20200702162416522.png)

#### 知识回顾

![image-20200702162609250](pic/image-20200702162609250.png)

### [覆盖与交换](https://www.bilibili.com/video/BV1YE411D7nH?p=34)

![image-20200702162710487](pic/image-20200702162710487.png)

#### 覆盖技术(现在不用此技术)

![image-20200702162825388](pic/image-20200702162825388.png)

![image-20200702163214981](pic/image-20200702163214981.png)

#### 交换技术

![image-20200702163804362](pic/image-20200702163804362.png)

![image-20200702164247403](pic/image-20200702164247403.png)

#### 知识回顾

![image-20200702164345728](pic/image-20200702164345728.png)

### 连续分配

![image-20200702164526849](pic/image-20200702164526849.png)

#### 单一连续分配

![image-20200702164821177](pic/image-20200702164821177.png)

#### 固定分区分配

![image-20200702165057403](pic/image-20200702165057403.png)

![image-20200702165340250](pic/image-20200702165340250.png)

#### 动态分区分配

三个问题

![image-20200702165547470](pic/image-20200702165547470.png)

##### 用什么数据结构记录内存使用情况

- 空闲分区表

- 空闲分区链

  ![image-20200702195418737](pic/image-20200702195418737.png)

##### 多个空闲分区内存满足程序要求，选择哪个进行分配

![image-20200702195632541](pic/image-20200702195632541.png)

![image-20200702195851068](pic/image-20200702195851068.png)

##### 如何进行分区的分配和回收操作

![image-20200702200433218](pic/image-20200702200433218.png)

![image-20200702200534555](pic/image-20200702200534555.png)

### 动态分区分配算法

![image-20200702200701686](pic/image-20200702200701686.png)

#### 首次适应算法

![image-20200702201005610](pic/image-20200702201005610.png)

查找第一个满足内存需求的。

#### 最佳适应

![image-20200702201237123](pic/image-20200702201237123.png)

#### 最坏适应

![image-20200702201416709](pic/image-20200702201416709.png)

#### 邻近适应

![image-20200702201703166](pic/image-20200702201703166.png)

#### 知识回顾

![image-20200702201735926](pic/image-20200702201735926.png)

### [基本分页存储管理的基本概念(没太懂)](https://www.bilibili.com/video/BV1YE411D7nH?p=37)

![image-20200702213046551](pic/image-20200702213046551.png)

![image-20200702213227310](pic/image-20200702213227310.png)

![image-20200702213428596](pic/image-20200702213428596.png)

![image-20200702213904471](pic/image-20200702213904471.png)

![image-20200702214134053](pic/image-20200702214134053.png)

![image-20200702214238761](pic/image-20200702214238761.png)

![image-20200702214403737](pic/image-20200702214403737.png)

#### 页表

![image-20200702214551525](pic/image-20200702214551525.png)

![image-20200702214712228](pic/image-20200702214712228.png)

![image-20200702214838175](pic/image-20200702214838175.png)

### [基本地址变换机构（没懂 笔记不全）](https://www.bilibili.com/video/BV1YE411D7nH?p=38)

![image-20200702215039704](pic/image-20200702215039704.png)

### 没学

https://www.bilibili.com/video/BV1YE411D7nH?p=39

https://www.bilibili.com/video/BV1YE411D7nH?p=40

https://www.bilibili.com/video/BV1YE411D7nH?p=41

https://www.bilibili.com/video/BV1YE411D7nH?p=42

### 虚拟内存的基本概念

![image-20200702220351921](pic/image-20200702220351921.png)

![](pic/image-20200702220642197.png)

![image-20200702221147991](pic/image-20200702221147991.png)

![image-20200702221414142](pic/image-20200702221414142.png)

![image-20200702221802799](pic/image-20200702221802799.png)

![image-20200702221904561](pic/image-20200702221904561.png)

### 没学

https://www.bilibili.com/video/BV1YE411D7nH?p=44

https://www.bilibili.com/video/BV1YE411D7nH?p=45

https://www.bilibili.com/video/BV1YE411D7nH?p=46

## 文件管理

### 初识文件管理

![image-20200705155033810](pic/image-20200705155033810.png)

![image-20200705155402981](pic/image-20200705155402981.png)

![image-20200705155448884](pic/image-20200705155448884.png)

![image-20200702223531041](pic/image-20200702223531041.png)

![image-20200705155611225](pic/image-20200705155611225.png)

![image-20200705155743583](pic/image-20200705155743583.png)

![image-20200705155836061](pic/image-20200705155836061.png)

![image-20200705155955343](pic/image-20200705155955343.png)

![image-20200705160126099](pic/image-20200705160126099.png)

![image-20200705160155849](pic/image-20200705160155849.png)

![image-20200705160246860](pic/image-20200705160246860.png)

### 文件的逻辑结构

![image-20200705160422163](pic/image-20200705160422163.png)

#### 无结构文件（流式文件）

![image-20200705160505107](pic/image-20200705160505107.png)

#### 有结构文件

![image-20200705160730954](pic/image-20200705160730954.png)

![image-20200705160758199](pic/image-20200705160758199.png)

##### 顺序文件

![image-20200705160925323](pic/image-20200705160925323.png)

![](pic/image-20200705161259645.png)

##### 索引文件
